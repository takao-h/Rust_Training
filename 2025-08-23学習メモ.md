### これまでの学習メモ

#### やったこと (What was done)

*   **Rust学習環境のセットアップ:** `cargo new --lib rust_training_course` コマンドで、Rustの標準的なライブラリプロジェクトを作成しました。
*   **`.gitignore`ファイルの準備:** RustプロジェクトでGit管理する際に不要なファイルを無視するための`.gitignore`ファイルを作成しました。
*   **レッスンファイルの生成:** Lesson 1からLesson 10までのすべてのソースファイル（`src/lessonX_*.rs`）とテストファイル（`tests/lessonX_*.rs`）を生成しました。
*   **Lesson 1 (`add`関数) の実装:**
    *   2つの`i32`を受け取り、その和を返す`add`関数を実装しました。
    *   Rustの関数の定義方法と、最後の式が戻り値になる「式指向」の特性を学びました。
*   **Lesson 2 (`check_number`関数) の実装:**
    *   `i32`を受け取り、"Positive", "Negative", "Zero"を返す`check_number`関数の実装に取り組みました。
    *   `match`式を使った数値の分岐に挑戦しました。
*   **Lesson 3 (所有権と借用) の実装:**
    *   `take_ownership`、`borrow_string`、`change_string`関数を実装し、テストをパスさせました。
    *   Rustの所有権、ムーブ、不変借用、可変借用の概念をコードで体験しました。

#### 躓いたところ (Where I struggled)

*   **`fibonacci.rust`の`main`関数:** 最初にご自身で書かれた`fibonacci.rust`がコンパイルできなかった際、Rustプログラムのエントリーポイントである`main`関数の必要性を認識しました。
*   **関数の戻り値の書き方:** `add`関数で、`a + b;` のようにセミコロンをつけてしまい、戻り値が期待通りにならない点に戸惑いました。
*   **`match`式の使い方（数値分岐）:**
    *   `match`式で数値を分岐させる際のパターン（特定の値、範囲、ガード句）の選択に悩みました。
    *   `match`アームの戻り値の型と、関数の戻り値の型が一致しないというコンパイルエラーに直面しました。
    *   特に、`&str`リテラルを`String`型として返す際に、`.to_string()`メソッドが必要であることに気づきました。
    *   `match`式全体が関数の最後の式である場合、セミコロンが不要である点を再確認しました。
*   **所有権、ムーブ、借用の概念:**
    *   Rustの所有権システム（オーナー、ムーブ、借用）の抽象的な概念を理解するのに苦労しました。
    *   特に、関数に`String`を渡すと所有権が移動し、元の変数が使えなくなる点や、`&`と`&mut`の違い、そしてそれらが同時に存在できるルール（1つの可変参照 or 複数の不変参照）の理解が最初の壁でした。

#### 学び (What I learned)

*   **Rustプロジェクトの基本構造:** `cargo`を使ったプロジェクト作成と、`src/`、`tests/`といったディレクトリ構成の重要性を理解しました。
*   **テストの実行方法:** `cargo test --test <テストファイル名>`で特定のテストを実行する方法を学びました。
*   **関数の定義と戻り値:**
    *   `pub fn function_name(param: Type) -> ReturnType { ... }` というRustの関数定義の基本構文。
    *   Rustが「式指向」言語であること、つまり関数の最後のセミコロンなしの式が戻り値となることを深く理解しました。
*   **`String`と`&str`の違い:** Rustにおける所有された文字列（`String`）と、借用された文字列スライス（`&str`）という、メモリ管理の根幹に関わる重要な概念の区別を学びました。
*   **型変換:** `&str`から`String`への変換に`.to_string()`を使う必要があることを学びました。
*   **`match`式の活用:**
    *   `match`が単なる`switch`文ではなく、強力なパターンマッチングの機能を持つこと。
    *   数値の範囲指定（`1..=i32::MAX`）や、`if`ガードを使ったより柔軟な条件分岐の方法。
    *   `match`のすべてのアームが同じ型を返す必要があるというルール。
*   **`if/else`と`match`の使い分け:** 数値の単純な分岐では`if/else`が読みやすい場合もあるが、`match`も強力な選択肢であることを認識しました。
*   **Rustのコンパイラエラー:** エラーメッセージを読み解き、型不一致や関数未定義などの問題を特定し、解決する経験を積みました。
*   **所有権の基本ルール:** 各値にはオーナーが1つだけ存在し、オーナーがスコープを抜けると値がドロップされること。
*   **ムーブセマンティクス:** `String`のような型を代入したり関数に渡したりすると、所有権が移動し、元の変数が無効になること。
*   **クローン (`.clone()`):** 所有権を移動させずに値をコピーする方法。
*   **不変参照 (`&T`):** 値を読み取るだけで変更できない参照。同時に複数存在可能。
*   **可変参照 (`&mut T`):** 値を読み書きできる参照。同時に1つしか存在できない。
*   **借用のルール:** 1つの可変参照か、複数の不変参照のどちらかしか同時に存在できないという、Rustのメモリ安全性を保証する重要なルール。
*   **関数のシグネチャと所有権:** 関数の引数の型（`String`, `&str`, `&mut String`）が、所有権の挙動に直接影響すること。